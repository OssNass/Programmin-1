---
theme: ./slidev-theme-penguin-rtl
colorSchema: light
class: text-center
transition: slide-right
title: "المحاضرة 4: المتحولات والثوابت والأنظمة العددية في C++"
mdc: true
author: Dr.Suhel AlHammoud & Dr. Ossama Nasser
exportFilename: "4"
layout: cover
highlighter: shiki
---
# المحاضرة 4
## المتحولات والثوابت والأنظمة العددية في C++
### د. سهيل الحمود
### د. أسامه ناصر
2025-2026

---



#   الفهرس 
- المتحولات Variables
- الثوابت Constants
- مجالات الرؤية Variable Scopes
    - محلي Local
    - عام Global
- أنواع المتحولات
- تمثيل الأعداد بالثنائي
- من الثنائي للعشري
- من العشري للثنائي
- عمليات الجمع والطرح
- Overflow و Underflow

---

# المتحولات Variables
- المتحول هو مكان في الذاكرة يُخزّن قيمة مؤقتة أثناء تنفيذ البرنامج.
- لكل متحول:
    - اسم
    - نوع Type
    - قيمة Value
    - موقع في الذاكرة Address
- مثال:
```cpp
int age = 20;
float salary = 4500.75;
char grade = 'A';
```

---

# ما هي الثوابت؟

- الثوابت هي قيم **لا يمكن تغييرها** أثناء تنفيذ البرنامج.
- تساعد في زيادة **الأمان**، **وضوح الكود**، و**سهولة الصيانة**.
- نستخدمها عندما نحتاج قيمة ثابتة لا يجب أن تتغير.

---

# تعريف الثوابت باستخدام const

```cpp
const int MAX_USERS = 100;
const float PI = 3.14159;
const char GRADE = 'A';
```

- الكلمة المحجوزة `const` تمنع تغيير القيمة.
- يجب إعطاء الثابت قيمة عند تعريفه مباشرة.
- 
---

# تعريف الثوابت باستخدام define

```cpp
#define PI 3.14159
#define MAX_SIZE 256
```

- هذا توجيه لمعالج النصوص (Preprocessor).
- لا يقوم بفحص النوع (No type checking).
- يتم استبداله نصيًا قبل عملية الترجمة.

---

#  الفرق بين `const` و `define#` 
| الميزة                     | const  | define#                |
| -------------------------- | ------ | ---------------------- |
| فحص النوع                  | ✔ نعم  | ✖ لا                   |
| سهولة التتبع أثناء التصحيح | ✔ أسهل | ✖ أصعب                 |
| احترام مجال الرؤية         | ✔ نعم  | ✖ لا                   |
| التخزين في الذاكرة         | ✔ نعم  | ✖ لا (استبدال نصي فقط) |

---

# الثوابت التعبيرية (`constexpr`)

```cpp
constexpr int SIZE = 10;
constexpr int VALUE = SIZE * 2;
```

- يتم حسابها **وقت الترجمة**.
- أسرع وأكثر كفاءة.

---

# الفرق بين

## `const` و `constexpr` في C++

- كلاهما يُستخدم لتعريف **ثوابت**.
- لكن الفرق الأساسي:
- `const`: قد تُحدد قيمته **وقت الترجمة أو وقت التشغيل**.
- `constexpr`: يجب أن تُحدد قيمته **وقت الترجمة فقط**.

---

# مثال عن const

- يعرّف قيمة لا يمكن تغييرها.
- قد تعتمد قيمته على حساب يتم وقت التشغيل.

```cpp
int a;
cin >> a; // قيمة runtime
const int x = a; // مسموح
```
- لا يضمن أن القيمة ثابتة وقت الترجمة.

---

# مثال عن  constexpr 
- يضمن أن القيمة تُحسب **وقت الترجمة**.
- يجب أن تكون القيمة معروفة مسبقاً.

```cpp
constexpr int x = 10; // صحيح
```
- لا يمكن استخدام قيم runtime معه.

```cpp
int a;
cin >> a;
constexpr int x = a; // خطأ
```

---

# الثوابت الحرفية (Literal Constants)

أمثلة:

```cpp
10 // ثابت عددي من نوع int
3.14 // ثابت من نوع double
'A' // ثابت محرفي
true // ثابت منطقي
"Hello" // ثابت نصي
```
---

# ثوابت التعداد (Enum Constants)

```cpp
enum Direction {NORTH,SOUTH,EAST,WEST};


Direction d;
d = NORTH;

if (d == NORTH) {
    cout << "Going North" << endl;
}

```
- ينشئ مجموعة من القيم الثابتة المرتبطة ببعضها.

---

# لماذا نستخدم الثوابت؟
- منع تغيير القيم المهمة بالخطأ.
- جعل الكود أوضح وأسهل قراءة.
- تسهيل عملية صيانة البرامج.
- تحسين أداء البرنامج عبر التحسينات التي يجريها المترجم.

---


# مجالات الرؤية Variable Scopes
 مجال الرؤية هو جزء البرنامج الذي يمكن فيه الوصول للمتحول.
هنالك نوعان من المتغيرات وفق مجال الرؤية:
- متغيرات محلية
- متغيرات عامة

---

# المتغيرات المحلية Local Variables

- تُعرّف داخل تابع أو كتلة.
- ينتهي وجودها بانتهاء التابع.

```cpp

void test(){
    int x = 10; // متغير محلي داخل تابع
}

{
    int y = 20;// متغير محلي داخل كتلة 
}

// x , y غير معروفان هنا
```

---

# المتحولات العامة Global

- تُعرّف خارج جميع التوابع.
- يمكن الوصول لها من جميع أجزاء البرنامج.
```cpp
// file1.cpp
#include <iostream>
using namespace std;
int globalVar = 100; // definition

// file2.cpp
#include <iostream>
using namespace std;
extern int globalVar; // declaration
void display() {
    cout << globalVar << endl;
}

```
---

# أنواع المتحولات
- رقمية
- محارف
- عائمة
- بوليانية
- مؤشرات
- مركبة (سنتعرف عليها لاحقاً)

---

# النظام الثنائي Binary System
- الحاسوب لا يفهم إلا 0 و 1
- نظام العد الثنائي أساس تخزين الأعداد
- أمثلة:
```
1₁₀ = 1₂
5₁₀ = 101₂
15₁₀ = 1111₂
```

---

# من الثنائي للعشري
- نحسب قيمة كل خانة:
```
1011₂ = 1×2³ + 0×2² + 1×2¹ + 1×2⁰ = 11₁₀
```

---

# من العشري للثنائي
- نقسم العدد على 2 عدة مرات بشكل عودي ونأخذ قيم البواقي لناتج القسمة الصحيحة.
- مثال:
```

13 / 2 = 6 , remains = 1 (الخانة الأقل أهمية)
6 / 2 = 3, remains = 0
3 / 2 = 1, remains = 1
1 / 2 = 0, remains = 1 (الخانة الأكثر أهمية)

13 decimal =  1101 binary
```

---

# Binary to Decimal
<B2D />

---

# Decimal to Binary
<D2B />

---

<Ieee754 />

---


# عمليات الجمع والطرح بالثنائي

عمليات **الجمع في النظام الثنائي** تشبه الجمع في النظام العشري، لكن باستخدام رقمين فقط:
**0 و 1**.
القاعدة الأساسية:

* **1 + 0 = 1**
* **0 + 1 = 1**
* **0 + 0 = 0**
* **1 + 1 = 10**  ← هنا ينتج 0 ويُحمَل 1 (Carry)
*
## قواعد الحمل (Carry) في الجمع الثنائي

* إذا كان الناتج 2 (أي 1 + 1) نكتب **0** ونضيف **1** كحمل للخانة التالية.
* إذا كان 1 + 1 + 1 (مع حمل سابق) يكون الناتج **11**
  نكتب **1** ويحمل **1**.

---

## **أمثلة على الجمع الثنائي**

### **1) مثال بسيط**

```
  1
 0110
+0011
------
 1001
```

الخطوات:

* 0 + 1 = 1
* 1 + 1 = 10 → نكتب 0 ونحمل 1
* 1 (الحمل) + 1 + 0 = 10 → نكتب 0 ونحمل 1
* 1 (الحمل) + 0 + 0 = 1

---

###  مثال مع حمل مستمر

```
 111
 1011
+0111
------
10010
```

الشرح:

* 1 + 1 = 10 → نكتب 0 ونحمل 1
* 1 (حمل) + 1 + 1 = 11 → نكتب 1 ونحمل 1
* 1 (حمل) + 0 + 1 = 10 → نكتب 0 ونحمل 1
* 1 (حمل) + 1 + 0 = 10 → نكتب 0 ونحمل 1
* نكتب الحمل الأخير في البداية → 1

---

#  مفهوم الفيض و النقصان Overflow و Underflow

---

#  ما هو الفيض (Overflow)؟

## **ما هو الفيض؟**

يحدث الفيض عندما ينتج عن العملية الحسابية الرقمية التي ينتج عنها رقم **أكبر من الحد الأقصى** لنوع البيانات.

### مثال:

إضافة 1 إلى INT_MAX في نوع int.

---


# **مثال: فيض عند الجمع**

```
int a = INT_MAX;
int b = 1;
int c = a + b;  // فيض
```

**النتيجة:**
تتجاوز قيمة الناتج الحد الأقصى وتؤدي إلى سلوك غير معرّف.

---

#  مثال على الفيض في الطرح


```
int a = INT_MAX;
int b = -10;
int c = a - b;  // فيض
```

يشبه هذا الجمع لأن طرح عدد سالب يعادل إضافة عدد موجب أكبر مما يسمح به النوع.

---

#  النقصان (Underflow)؟


يحدث النقصان عندما ينتج عن العملية الحسابية رقم **أقل من الحد الأدنى** لنوع البيانات.

### مثال:

طرح 1 من INT_MIN.

---


# مثال: نقصان عند الطرح

```
int a = INT_MIN;
int b = 1;
int c = a - b;  // نقصان
```

**النتيجة:**
تتجاوز القيمة الحد الأدنى وتؤدي إلى سلوك غير معرّف.

---


### ✔️ **ملاحظات مهمة:**

* الفيض والنقصان في الأنواع ذات الإشارة (**signed**) يؤديان إلى **سلوك غير معرّف**.
* الفيض والنقصان في الأنواع غير المؤشرة (**unsigned**) سلوكهما **مُعرّف** 

---